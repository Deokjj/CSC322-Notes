<HTML>
<HEAD>
<TITLE>Revision Control</TITLE>
</HEAD>
<BODY ALIGN=JUSTIFY>
<HR><!------------------------------------------------------------------------>
<CENTER>
<H1>Revision Control</H1>
</CENTER>
Last modified Monday, 22-Aug-2016 11:19:42 EDT.
<HR><!------------------------------------------------------------------------>
<UL>
<LI> Configuration Management
     <UL>
     <LI> Products of the software development process include product code,
          documents, test vectors, test harnesses.  
     <LI> Throughout the lifecycle, these will change; <i>configuration 
          management</i> monitors and controls these changes.  
     <LI> Elements of configuration management include:
          <UL>
          <LI> Build control - determining which versions of code are
               required to build a product (make, ant, etc.)
          <LI> <STRONG>Revision control</STRONG> - keeping track of various 
               versions of code and documentation (RCS, CVS, SVN, etc.)
          <LI> Change control - the procedure by which code and documentation 
               changes are reviewed, decided upon, incorporated and recorded.
          </UL>
     <LI> Reasons for wanting to formalize revision control include:
          <UL>
          <LI> Learn from history - we may need to revisit previous
               versions of code and documentation to review changes and
               validate them;
          <LI> Support multiple product versions - not all users want to
               upgrade so we still need to support old versions of the code
               in addition to the most recent version;
          <LI> Support concurrent development - without suitable controls, 
               multiple programmers working on the same source tree
               can overwrite each others' work.
          </UL>
     </UL>
<P>
<LI> Versions and Version Numbering Schemes
     <UL>
     <LI> After release of a system there are two sources of changes:
          <UL>
          <LI> Continuing development causes new internal versions to be
               created.
          <LI> Defects are detected as the product is used in the field
               and fixes for these defects are applied to the release version
               of the product.  
          </UL>
     <P>
     <IMG SRC="Versioning.GIF" WIDTH=90%>
     <LI> Concurrent development continues until it is time to create 
          a new release of the product.  
          <UL>
          <LI> The new release incorporates both new features and 
               functionality that have been generated by ongoing development 
               and any defect fixes that have been made as part of product 
               maintenance.  
          <LI> Some time before the next release, product development and 
               product maintenance (defect fixes) are suspended while the 
               development and maintenance lines are merged into a single
               pre-release version of the product.  
          <LI> After successfully creating the pre-release merged version a 
               new release is created.
          </UL>
     <LI> <EM>Version numbers</EM> are used to identify the various versions
          of a product throughout its lifecycle.  
          <UL>
          <LI> A <i>version numbering scheme</i> determines how version numbers 
               are generated and assigned.  
          <LI> Example:
               <UL>
               <LI> Uses a major and a minor version number.  
               <LI> An even major number is assigned to production versions that
                    are released for general use.  
               <LI> An odd major version number is assigned to internal 
                    development versions.  
               <LI> The minor number indicates an incremental change from a 
                    previous version.
               </UL>
          </UL>
     <LI> File and module version numbers
          <UL> 
          <LI> A product might consist of many individual modules each of 
               which progresses through several versions 
          <LI> The various versions of the modules are given their own
               numbers. 
          <LI> Need some way of tracking of the module versions and which
               versions of each of the modules are used to make a version 
               of the product.
          </UL>
     </UL>
<P>
<LI> Tracking changes in files
     <UL>
     <LI> Creating a new file every time a modification is made is possible, 
          but 
          <UL>
          <LI> Keeping track of the files would be unwieldy for even a 
               small number of files.  
          <LI> It would waste space; a one-byte change to every file in 
               the tree would double the size of the tree.  
          <LI> A more efficient way is to store the initial version and record 
               changes
          <LI> Or store the most recent version and record undo information.
          </UL>
     <LI> To regenerate a previous version of a file, start with the 
          current version then apply reverse changes until the desired version
          is created.  
     <LI> Example: 
          <UL>
          <LI> Start with the file 
               <A HREF="MyCode/HelloWorld.c-0"><TT>HelloWorld.c-0</TT></a>
          <LI> Modify the file to produce an extended greeting 
               <A HREF="MyCode/HelloWorld.c-1"><TT>HelloWorld.c-1</TT></a>
          <LI> Calculate the differences between the two files using
               <PRE>
prompt> diff -e HelloWorld.c-1 HelloWorld.c-0 > delta.1 </PRE>
               and you get <A HREF="MyCode/delta.1.original"><TT>delta.1</TT></A>
               <PRE>
13a
    printf("Have a most excellent day\n");
.
12c
    printf("Hello world\n");
.
10d</PRE>
          <LI> <TT>delta.1</TT> contains a list of commands which, when 
               executed by the <TT>ed</TT> editor will change 
               <TT>HelloWorld.c-1</TT> back into <TT>HelloWorld.c-0</TT> 
          <LI> To make <TT>ed</TT> work as a stream editor, add a line
               <TT>1,$p</TT> to the end of <A HREF="MyCode/delta.1.withprint">
               <TT>delta.1</TT></A>, so <TT>ed</TT> prints out the file after 
               editing.
          <LI> Delete <TT>HelloWorld.c-0</TT> and generate on demand with
               <PRE>
prompt> ed - HelloWorld.c-1 &lt; delta.1</PRE>
          </UL>
     </UL>
<P>
<LI> Synchronization in the presence of concurrency 
     <UL>
     <LI> A pessimistic protocol forces a programmer to obtain an 
          explicit lock on the file before it is modified and to
          release the lock when the modifications are complete; 
          only one programmer can ever be modifying a file at any time.  
     <LI> An optimistic protocol assumes that the likelihood of two 
          programmers modifying the same file at the same time is 
          low, so the protocol allows multiple programmers to make 
          copies of a file and modify the copies as they please.  
          The protocol detects any conflicts generated by attempts 
          to place modified files back into the tree and forces
          resolution of all conflicts before replacement is allowed.
     </UL>
<P>
<LI> Revision Control System (RCS)
     <UL>
     <LI> RCS stores and retrieves multiple versions of files.  
     <LI> Uses pessimistic concurrency control.
     <LI> Changes create new versions of a file and the previous versions 
          are still accessible. 
     <LI> RCS maintains a complete history of changes and in addition to 
          recording the change, also records information including who made 
          the change, the date and time the change was made and a log 
          message summarizing the change.
     <LI> Previous versions of files can be accessed by a number of keys
          including version number, symbolic name, date, author and state.
     <LI> The programs that make up RCS are:
          <UL>
          <LI> <TT>ci</TT> check in a new version of a file.
          <LI> <TT>co</TT> check out a version of a file.
          <LI> <TT>ident</TT> list information about the source files
               that were used to build a file.
          <LI> <TT>rcsclean</TT> clean up working copies of files.
          <LI> <TT>rcsdiff</TT> compare two versions of a file.
          <LI> <TT>rcsmerge</TT> incorporate changes between two
               revisions of a file.
          <LI> <TT>rlog</TT> print log and other information about RCS files.
          </UL>
     <LI> Checking in files
          <UL>
          <LI> Suppose we have a program that consists of two modules:
               <A HREF="MyCode/main.c-BeforeRCS">main.c</A> and 
               <A HREF="MyCode/greet.c-BeforeRCS">greet.c</A>
          <LI> Add a comment with <TT>$Log$</TT>, and a static string
               variable <TT>static char RCSId[] = "$Id$";</TT>:
               <A HREF="MyCode/main.c-WithRCSTags">main.c</A> and 
               <A HREF="MyCode/greet.c-WithRCSTags">greet.c</A>
          <LI> Store the files under RCS by creating a directory called RCS 
               and checking them in:
               <PRE>
prompt> ls
greet.c  main.c
prompt> mkdir RCS
prompt> ci main.c
RCS/main.c,v  <--  main.c
enter description, terminated with single '.' or end of file:
NOTE: This is NOT the log message!
>> The HelloWorld program driver
>> .
initial revision: 1.1
done
prompt> ci greet.c
RCS/greet.c,v  <--  greet.c
enter description, terminated with single '.' or end of file:
NOTE: This is NOT the log message!
>> The HelloWorld program greeting
>> .
initial revision: 1.1
done

prompt> ls
RCS/
prompt> ls RCS
greet.c,v  main.c,v </PRE>
          <LI> RCS takes our files and a description of each, assigns each 
               version number 1.1, then stores them in its internal format 
               in the RCS directory.
          </UL>
     <LI> Checking out files
          <UL>
          <LI> A source file can be retrieved by checking it out:
               <PRE>
prompt> co main.c
RCS/main.c,v  --&gt;  main.c
revision 1.1
done
prompt> ls -l
total 2
drwx------  2 stefan  user  512 Jan 15 22:30 RCS/
-r--------  1 stefan  user  706 Jan 15 22:30 main.c </PRE>
          <LI> Checking in <A HREF="MyCode/main.c-AfterRCS-ci-co">
               <TT>main.c</TT></A> caused RCS to make some additions 
               to the source file:
               <UL>
               <LI> The strings <TT>$Log$</TT> and <TT>$Id$</TT> have been 
                    replaced respectively by a a history of modifications to 
                    the file and an identifying string.  
               <LI> The log is provided for anyone reading the source
                    file, so is commented out.  
               <LI> The identifying string is used to initialize a character 
                    array local to the source file.  
               </UL>
          <LI> RCS has retrieved the source file and set it to be read-only.  
               This is an indication that we are not supposed to modify the 
               source file.
          <LI> If we changed the permissions on <TT>main.c</TT>, edited it
               and tried to check in the edited version
               <PRE>
prompt> ci main.c
RCS/main.c,v  <--  main.c
ci: RCS/main.c,v: no lock set by stefan
prompt> rm -f main.c </PRE>
          <LI> RCS prevents checking in the modified file because it was 
               not locked.
          </UL>
     <LI> Checking out with locking
          <UL>
          <LI> Locking prevents one programmer from overwriting the
               changes made by another.  
          <LI> This is pessimistic
          <LI> Check out and lock the file, edit it then check in the 
               <A HREF="MyCode/main.c-AfterRCS-co-vi">new version</A>:
               <PRE>
prompt> co -l main.c
RCS/main.c,v  -->  main.c
revision 1.1 (locked)
done
prompt> ls -l
total 2
drwx------  2 stefan  user  512 Jan 15 22:39 RCS/
-rw-------  1 stefan  user  712 Jan 15 22:39 main.c
prompt> vi main.c
   ... edit to add "It's a great day." to the greeting ...
prompt> ci main.c
RCS/main.c,v  <--  main.c
new revision: 1.2; previous revision: 1.1
enter log message, terminated with single '.' or end of file:
>> Extended the greeting
>> .
done</PRE>
          </UL>
     <LI> Compiling
          <UL>
          <LI> Check out the source files without locking and compile 
               in the usual way.
               <PRE>
prompt> co main.c greet.c
RCS/main.c,v  -->  main.c
revision 1.2
done
RCS/greet.c,v  -->  greet.c
revision 1.1
done
prompt> gcc -o greet main.c greet.c </PRE>
          <LI> This version of <TT>greet</TT> uses version 1.1 of 
               <A HREF="MyCode/greet.c-AfterRCS"><TT>greet.c</TT></A> and 
               version 1.2 of <A HREF="MyCode/main.c-AfterRCS-co-vi-ci">
               <TT>main.c</TT></A>.
          </UL>
     <LI> Identifying module versions in executables
          <UL>
          <LI> Use the <TT>ident</TT> command to search through an 
               executable for identifying strings and print them:
               <PRE>
prompt> ident greet
greet:
     $Id: main.c,v 1.2 2001/01/16 03:42:26 stefan Exp $
     $Id: greet.c,v 1.1 2001/01/16 03:25:14 stefan Exp $ </PRE>
          <LI> Given an executable this provides a way to determine which
               versions of its constituent modules were used to build it.
          </UL>
     <LI> Getting information on revisions
          <UL>
          <LI> The <TT>rlog</TT> command can be used to print detailed 
               information about a file:
               <PRE>
prompt> rlog main.c

RCS file: RCS/main.c,v
Working file: main.c
head: 1.2
branch:
locks: strict
access list:
symbolic names:
keyword substitution: kv
total revisions: 2;     selected revisions: 2
description:
The HelloWorld program driver
----------------------------
revision 1.2
date: 2001/01/16 03:42:26;  author: stefan;  state: Exp;  lines: +6 -3
Extended the greeting
----------------------------
revision 1.1
date: 2001/01/16 03:25:06;  author: stefan;  state: Exp;
Initial revision
----------------------------
============================================================================= </PRE>
          <LI> <TT>rlog</TT> has options that allow printing of more selective
               information such as a list of all files that are locked and 
               all the files that are locked by a particular user.
          </UL>
<!--
     <LI> Finding differences between revisions
          <UL>
          <LI> <TT>rcsdiff</TT> can be used to print the differences between 
               two versions of a file.  
          <LI> Example: <TT>rcsdiff -r1.1 main.c</TT> lists the differences 
               between the version 1.1 of <TT>main.c</TT> and the version 
               in the current directory.
          </UL>
     <LI> Marking a release
          <UL>
          <LI> <TT>rcs</TT> command is a utility that is used to change 
               RCS file attributes.  
          <LI> One use is to mark the latest versions of all the modules in 
               an RCS directory with a common label.
               <PRE>
prompt> rcs -nalpha: RCS/* </PRE>
               marks version 1.1 of <TT>greet.c</TT> and version 1.2 of
               <TT>main.c</TT> with the tag <TT>alpha</TT>.  
          <LI> When creating a release of the program, this gives a way of 
               referring to the particular versions of each file that are 
               used to build the release.
          </UL>
-->
     <LI> Creating a branch
          <UL>
          <LI> RCS uses a specific numbering scheme for branched versions.  
          <LI> To create a branch from version 1.2 of <TT>main.c</TT>, check 
               in the <A HREF="MyCode/main.c-AfterRCS-co-vi-2">new version</A> 
               with revision number 1.2.1 .
               <PRE>
prompt> co -l main.c
RCS/main.c,v  -->  main.c
revision 1.2 (locked)
done
prompt> vi main.c
   ... Add the comment "//----Call the output function" ...
prompt> ci -r1.2.1 main.c
RCS/main.c,v  <--  main.c
new revision: 1.2.1.1; previous revision: 1.2
enter log message, terminated with single '.' or end of file:
>> Added a comment
>> .
done </PRE>
          <LI> 1.2.1 identifies <EM>branch</EM> 1 which is made from 
               revision 1.2.  
          <LI> A second branch could be created from 1.2, which would be 
               numbered 1.2.2.
          <LI> The first version in this branch (the version just checked in) 
               is numbered 1.2.1.1; subsequent versions are numbered 
               <A HREF="MyCode/main.c-AfterRCS-co-vi-branch">1.2.1.2</A>,
               1.2.1.3 etc.
               <PRE>
prompt> co -r1.2.1.1 -l main.c
RCS/main.c,v  -->  main.c
revision 1.2.1.1 (locked)
done
prompt> vi main.c
   ... Add "really" into extended greeting ...
prompt> ci main.c
RCS/main.c,v  <--  main.c
new revision: 1.2.1.2; previous revision: 1.2.1.1
enter log message, terminated with single '.' or end of file:
>> Made the message more positive
>> .
done </PRE>
          </UL>
     <LI> Editing the main branch again
          <UL>
          <LI> The main branch can be edited like normal.
               <PRE>
prompt> co -l main.c
prompt> vi main.c
   ... Add greeting using argv[1] ...
prompt> ci main.c
RCS/main.c,v  <--  main.c
new revision: 1.3; previous revision: 1.2
enter log message, terminated with single '.' or end of file:
>> Add greeting with argv[1]
>> .
done </PRE>
          </UL>
     <LI> Joining branches
          <UL>
          <LI> Suppose <A HREF="MyCode/main.c-After-co-vi-3-ci">version 1.3</A>
               of <TT>main.c</TT> is produced then 
               <A HREF="MyCode/main.c-AfterRCS-co-vi-branch">
               version 1.2.1.2</A> 
               has to be merged into version 1.3 to create version 1.4.  
          <LI> Check out 1.3, use <TT>rcsmerge</TT> to merge the
               differences between 1.2 and 1.2.1.2 into 1.3, and check 
               in the modified 1.3 as 1.4
               <PRE>
prompt> co -l main.c
RCS/main.c,v  -->  main.c
revision 1.3 (locked)
done
prompt> rcsmerge -r1.2 -r1.2.1.2 main.c
RCS file: RCS/main.c,v
retrieving revision 1.2
retrieving revision 1.2.1.2
Merging differences between 1.2 and 1.2.1.2 into main.c
rcsmerge: warning: conflicts during merge </PRE>
          <LI> If there are conflicts in the changes <TT>rcsmerge</TT>
               will print alerts, and highlight the changes in the
               <A HREF="MyCode/main.c-AfterRCS-merge">source file</A>.
               The programmer must edit the file and resolve the conflicts 
               manually to produce the 
               <A HREF="MyCode/main.c-AfterRCS-resolved">version that is
               checked in</A>.
               <PRE>
prompt> vi main.c
    ... Resolve the differences ...
prompt> ci main.c
RCS/main.c,v  <--  main.c
new revision: 1.4; previous revision: 1.3
enter log message, terminated with single '.' or end of file:
>> Merged v1.2.1.2 with v1.3
>> .
done </PRE>
          </UL>
<!--
     <LI> Outdating versions
          <UL>
          <LI> To outdate (remove) versions of a file, use 
               <TT>rcs -o</TT>&lt;range>.
          <LI> Check out a locked version of the file, outdate the 
               unwanted versions, and check in the file. 
          <LI> The checked in version is given the earliest available
               number.
               <PRE>
prompt> co -l main.c
RCS/main.c,v  -- >  main.c
revision 1.4 (locked)
done
prompt> rcs -o1.2:1.4 main.c
RCS file: RCS/main.c,v
deleting revision 1.4
deleting revision 1.3
deleting revision 1.2
done
prompt> rlog main.c

RCS file: RCS/main.c,v
Working file: main.c
head: 1.1
branch:
locks: strict
        stefan: 1.1
access list:
symbolic names:
        BETA: 1.2
keyword substitution: kv
total revisions: 1;     selected revisions: 1
description:
The HelloWorld program driver
----------------------------
revision 1.1    locked by: stefan;
date: 2001/02/23 21:24:27;  author: stefan;  state: Exp;
Initial revision
----------------------------
=============================================================================
prompt> ci main.c
RCS/main.c,v  <--  main.c
new revision: 1.2; previous revision: 1.1
enter log message, terminated with single '.' or end of file:
>> Updated version.
>> .
done
               </PRE>
-->
          </UL>
     </UL>
<P>
<LI> Concurrent Versions System (CVS)
     <UL>
     <LI> RCS stores multiple versions of files and coordinates updates 
          made by multiple programmers, but it has some shortcomings:
          <UL>
          <LI> It doesn't cope well with projects that span multiple
               directories.
          <LI> Increasingly, software development is becoming distributed
               in nature; projects like the Apache web server are being
               developed by programmers located throughout the world.  RCS
               alone is not sufficient to coordinate such a development
               process.
          <LI> In a large, distributed development effort, the strict
               locking enforced by RCS can prevent concurrent development; a
               programmer in Australia might have to wait some time
               before a colleague in Los Angeles gets to work and receives
               the email requesting that they release a lock that they hold 
               on a source file.
          </UL>
     <LI> CVS is a version control system that addresses issues RCS does not.
          <UL>
          <LI> CVS uses the notion of a central repository, which may be 
               a directory on a local computer or on a remote computer.  
          <LI> A repository can support multiple projects.
          <LI> Using a CVS client (clients exist for Unix and Windows 
               machines) entire directory trees are checked in to and out 
               of the repository.  
          <LI> The default locking model in CVS is known as <EM>unreserved 
               checkouts</EM>, i.e., optimistic concurrency control.
               <UL>
               <LI> Programmers check out a copy of the source and work on 
                    their individual copies concurrently
               <LI> The first programmer to check their code in updates the
                    repository and successive checkins force conflict 
                    resolution if it is necessary. 
               <LI> The conflict resolution procedure is similar to the one
                    used by RCS as shown above.
               </UL>
          </UL>
     <P>
     <LI> Creating a CVS repository
          <UL>
          <LI> Create a directory for CVS - all projects will live in it
          <LI> Set <TT>CVSROOT</TT> environment variable to that directory
          <LI> Initialize the repository with<BR>
               <TT>cvs init</TT><BR>
               Example:
               <PRE>
> mkdir CVS
> setenv CVSROOT /home/stefan/CVS
> cvs init </PRE>
          <LI> <TT>cd</TT> into the <A HREF="MyCode/GreetingProject">
               directory containing the project</A>
          <LI> Import into CVS with<BR>
               <TT>cvs import -m "</TT><EM>log msg</EM><TT>"</TT> <EM>projname</EM> <EM>vendortag</EM> <EM>releasetag</EM><BR>
               Example: 
               <PRE>
prompt> cd GreetingProject
prompt> cvs import -m "CVS the greeting project" GreetingProject Stefan Initial
N GreetingProject/main.c
N GreetingProject/greet.c

No conflicts created by this import </PRE>
               The <TT>N</TT> <EM>filename</EM> lines indicate that 
               the files are new
          </UL>
     <LI> Editing files
          <UL>
          <LI> Check out a working copy with<BR>
               <TT>cvs checkout</TT> <EM>projname</EM><BR>
               Example:
               <PRE>
prompt> mkdir WorkingArea
prompt> cd WorkingArea
prompt> cvs checkout GreetingProject
cvs checkout: Updating GreetingProject
U GreetingProject/greet.c
U GreetingProject/main.c </PRE>
... </PRE>
          <LI> Edit 'til you drop<BR>
               Example:
               <PRE>
prompt> cd GreetingProject
prompt> vi main.c
    ... Insert "crool" into greeting ... </PRE>
          <LI> If the repository might have been changed by another user
               while you were editing, find out what files have been changed
               with<BR>
               <TT>cvs update</TT> [<EM>filenames</EM>]<BR>
               Example:
               <PRE>
prompt> cvs update
cvs update: Updating .
M main.c </PRE>
               (More about this later.)
          <LI> See what changes you have made with<BR>
               <TT>cvs diff</TT> [<EM>filenames</EM>]<BR>
               Example:
               <PRE>
prompt> cvs diff
cvs diff: Diffing .
Index: main.c
===================================================================
RCS file: /home/stefan/CVS/GreetingProject/main.c,v
retrieving revision 1.1.1.1
diff -r1.1.1.1 main.c
19c19
<     Greet("Hello world.");
---
>     Greet("Hello crool world."); </PRE>
          <LI> Commit your changes with<BR>
               <TT>cvs commit -m "</TT><EM>log msg</EM> [<EM>filenames</EM>]<BR>
               Example:
               <PRE>
prompt> cvs commit -m "Made the world cruel" 
cvs commit: Examining .
Checking in main.c;
/home/stefan/GreetingProject/main.c,v  <--  main.c
new revision: 1.2; previous revision: 1.1
done </PRE>
          <LI> See the status of your working project vs the repository with<BR>
               <TT>cvs status</TT> [<EM>filenames</EM>]<BR>
               Example:
               <PRE>
prompt> cvs status main.c
===================================================================
File: main.c            Status: Up-to-date

   Working revision:    1.2     Tue Mar 21 18:18:44 2006
   Repository revision: 1.2     /home/stefan/CVS/GreetingProject/main.c,v
   Sticky Tag:          (none)
   Sticky Date:         (none)
   Sticky Options:      (none) </PRE>
          <LI> See what changes have taken place over time with<BR>
               <TT>cvs log</TT> [<EM>filenames</EM>]<BR>
               Example:
               <PRE>
prompt> cvs log main.c

RCS file: /home/stefan/public_html/Courses/CSC322-S06/Content/CTools/MyCode/CVS/GreetingProject/main.c,v
Working file: main.c
head: 1.2
branch:
locks: strict
access list:
symbolic names:
        Initial: 1.1.1.1
        Stefan: 1.1.1
keyword substitution: kv
total revisions: 3;     selected revisions: 3
description:
----------------------------
revision 1.2
date: 2006/03/21 18:18:44;  author: stefan;  state: Exp;  lines: +6 -3
Made the world cruel
----------------------------
revision 1.1
date: 2006/03/21 18:14:59;  author: stefan;  state: Exp;
branches:  1.1.1;
Initial revision
----------------------------
revision 1.1.1.1
date: 2006/03/21 18:14:59;  author: stefan;  state: Exp;  lines: +0 -0
CVS the greeting project
=============================================================================</PRE>
<!--
          <LI> See what changes there are between revisions with<BR>
               <TT>cvs diff -c -r</TT> <EM>revision</EM> <TT>-r</TT> <EM>revision</EM> [<EM>filenames</EM>]<BR>
               Example:
               <PRE>
prompt> vi TestParsing.c
...
cvs commit: Examining .
cvs commit: Examining TestFiles
cvs commit: Examining TestFiles/PUZ
Checking in TestParsing.c;
/home/graph/tptp/CVS/JJParser/TestParsing.c,v  <--  TestParsing.c
new revision: 1.3; previous revision: 1.2
done
prompt> cvs diff -c -r 1.1 -r 1.3 TestParsing.c
Index: TestParsing.c
===================================================================
RCS file: /home/graph/tptp/CVS/JJParser/TestParsing.c,v
retrieving revision 1.1
retrieving revision 1.3
diff -c -r1.1 -r1.3
*** TestParsing.c       24 Mar 2004 17:46:24 -0000      1.1
--- TestParsing.c       24 Mar 2004 17:50:46 -0000      1.3
***************
*** 16,26 ****
  //-----------------------------------------------------------------------------
  int main(int argc, char *argv[]) {
  
!     LISTNODE Head;
      LISTNODE AnotherHead;
      String InferenceRule;
      String PutNamesHere;
-     SIGNATURE Signature;
      ANNOTATEDFORMULA AnnotatedFormula;
      ANNOTATEDFORMULA DuplicatedAnnotatedFormula;
      FORMULA Literal;
--- 16,26 ----
  //-----------------------------------------------------------------------------
  int main(int argc, char *argv[]) {
  
!     LISTNODE HeadNodeWithMeaning;
!     int AnotherUselessVariable;
      LISTNODE AnotherHead;
      String InferenceRule;
      String PutNamesHere;
      ANNOTATEDFORMULA AnnotatedFormula;
      ANNOTATEDFORMULA DuplicatedAnnotatedFormula;
      FORMULA Literal; </PRE>
          <LI> Revert to a previous version with<BR>
               <TT>cvs update -r</TT> <EM>revision</EM> [<EM>filenames</EM>]<BR>
               Example:
               <PRE>
prompt> cvs update -r 1.2 TestParsing.c
U TestParsing.c </PRE>
          <LI> Add a new file with<BR>
               <TT>cvs add</TT> <EM>filenames</EM><BR>
               Example:
               <PRE>
prompt> vi NewFile.c
...
prompt> cvs update
cvs update: Updating .
? NewFile.c
cvs update: Updating TestFiles
cvs update: Updating TestFiles/PUZ
prompt> cvs add NewFile.c 
cvs add: scheduling file `NewFile.c' for addition
cvs add: use 'cvs commit' to add this file permanently
prompt> cvs update
cvs update: Updating .
A NewFile.c
cvs update: Updating TestFiles
cvs update: Updating TestFiles/PUZ
prompt> cvs commit -m "New file added"
cvs commit: Examining .
cvs commit: Examining TestFiles
cvs commit: Examining TestFiles/PUZ
RCS file: /home/graph/tptp/CVS/JJParser/NewFile.c,v
done
Checking in NewFile.c;
/home/graph/tptp/CVS/JJParser/NewFile.c,v  <--  NewFile.c
initial revision: 1.1
done </PRE>
          <LI> Remove a file with<BR>
               <TT>cvs rm</TT> <EM>filenames</EM><BR>
               Example:
               <PRE>
prompt> rm NewFile.c
prompt> cvs rm NewFile.c
cvs remove: scheduling `NewFile.c' for removal
cvs remove: use 'cvs commit' to remove this file permanently
prompt> cvs commit -m "New file removed"
cvs commit: Examining .
cvs commit: Examining TestFiles
cvs commit: Examining TestFiles/PUZ
Removing NewFile.c;
/home/graph/tptp/CVS/JJParser/NewFile.c,v  <--  NewFile.c
new revision: delete; previous revision: 1.1
done </PRE>
-->
          </UL>
     <LI> Working as a team
          <UL>
          <LI> Before doing a commit, do an update to ensure you have the 
               latest version (files may have been changed by another user)
          <LI> Detect conflicts between another users committed changes and
               your changes with<BR>
               <TT>cvs update</TT><BR>
               Example:
               <PRE>
another user> setenv CVSROOT /home/graph/stefan/CSC322/CVSInNotes/CVS
another user> cvs checkout GreetingProject
another user> cd GreetingProject
another user> vi main.c
   ... Change "crool" to "lovely" ...
another user> cvs commit -m "Changes by a kind user"
cvs commit: Examining .
Checking in main.c;
/home/stefan/CVS/GreetingProject/main.c,v  <--  main.c
new revision: 1.3; previous revision: 1.2
done</PRE>
<P>
               <PRE>
prompt> vi main.c
    ... Make it "very crool" ...
prompt> cvs update
cvs update: Updating .
RCS file: /home/stefan/CVS/GreetingProject/main.c,v
retrieving revision 1.2
retrieving revision 1.3
Merging differences between 1.2 and 1.3 into main.c
rcsmerge: warning: conflicts during merge
cvs update: conflicts found in main.c
C main.c
prompt> vi main.c
    ... Make it "very crool but lovely" ...
prompt> cvs commit -m "Conflict resolved"
cvs commit: Examining .
Checking in main.c;
/home/stefan/CVS/GreetingProject/main.c,v  <--  main.c
new revision: 1.4; previous revision: 1.3
done </PRE>
          </UL>

     <P>
     <LI> CVS on a remote repository
          <UL>
          <LI> Make sure you can <TT>ssh</TT> to the machine with the
               repository (without a password if you want to avoid entering
               it all the time)
          <LI> <TT>setenv CVS_RSH ssh</TT><BR>
               <TT>setenv CVSROOT :ext:</TT><EM>user@machine</EM><TT>:</TT><EM>remote path to repository</EM><BR>
          <LI> Proceed as before
          </UL>
<!--
     <LI> Versions and Branches
          <UL>
          <LI> A release is tagged with<BR>
               <TT>cvs tag</TT> <EM>tag label</EM><BR>
               Example:
               <PRE>
prompt> cvs tag Release-2004-3-25
cvs tag: Tagging .
T DataTypes.h
T Examine.c
T Examine.h
... </PRE>
          <LI> A release is retrieved with<BR>
               <TT>cvs update -r</TT> <EM>tag label</EM><BR>
               Example:
               <PRE>
prompt> cvs update -r Release-2004-3-25
cvs update: Updating .
U TestParsing.c
cvs update: Updating TestFiles
cvs update: Updating TestFiles/PUZ </PRE>
          <LI> Create a branch by checking out a release into a new directory
               and tagging it as a branch with<BR>
               <TT> cvs checkout -r</TT> <EM>tag project</EM><BR>
               <TT> cvs tag -b</TT> <EM>branch tag</EM><BR>
               Example:
               <PRE>
prompt> mkdir NewBranch
prompt> cd NewBranch
prompt> cvs checkout -r Release-2004-3-25 JJParser
cvs checkout: Updating JJParser
U JJParser/DataTypes.h
U JJParser/Examine.c
U JJParser/Examine.h
...
prompt> cd JJParser
prompt> cvs tag -b Release-2004-3-25-Bugfixes
cvs tag: Tagging JJParser
T JJParser/DataTypes.h
T JJParser/Examine.c
T JJParser/Examine.h
... </PRE>
          <LI> Edit and commit trunk to your hearts content<BR>
               Example:
               <PRE>
prompt> vi TestParsing.c
...
prompt> cvs update
cvs update: Updating .
M TestParsing.c
cvs update: Updating TestFiles
cvs update: Updating TestFiles/PUZ
prompt> cvs commit -m "Updated development"
cvs commit: Examining .
cvs commit: Examining TestFiles
cvs commit: Examining TestFiles/PUZ
Checking in TestParsing.c;
/home/graph/tptp/CVS/JJParser/TestParsing.c,v  <--  TestParsing.c
new revision: 1.9; previous revision: 1.8
done </PRE>
          <LI> Edit and commit branch to your hearts content<BR>
               Example:
               <PRE>
prompt> vi TestParsing.c
...
prompt> cvs update
cvs update: Updating .
M TestParsing.c
cvs update: Updating TestFiles
cvs update: Updating TestFiles/PUZ
prompt> cvs commit -m "Bugfixed that variable"
cvs commit: Examining .
cvs commit: Examining TestFiles
cvs commit: Examining TestFiles/PUZ
Checking in TestParsing.c;
/home/graph/tptp/CVS/JJParser/TestParsing.c,v  <--  TestParsing.c
new revision: 1.7.2.1; previous revision: 1.7
done </PRE>
          <LI> Merge the branch back into the trunk with<BR>
               <TT>cvs update -j</TT> <EM>branch tag</EM><BR>
               Example:
               <PRE>
prompt> cvs update -j Release-2004-3-25-Bugfixes
cvs update: Updating .
RCS file: /home/graph/tptp/CVS/JJParser/TestParsing.c,v
retrieving revision 1.7
retrieving revision 1.7.2.1
Merging differences between 1.7 and 1.7.2.1 into TestParsing.c
rcsmerge: warning: conflicts during merge
cvs update: Updating TestFiles
cvs update: Updating TestFiles/PUZ
prompt> vi TestParsing.c
...
prompt> cvs commit -m "Merged bugfixes"
cvs commit: Examining .
cvs commit: Examining TestFiles
cvs commit: Examining TestFiles/PUZ
Checking in TestParsing.c;
/home/graph/tptp/CVS/JJParser/TestParsing.c,v  <--  TestParsing.c
new revision: 1.10; previous revision: 1.9
done </PRE>
          </UL>
     <LI> There's some weird stuff I have not understood yet
-->
     </UL>
</UL>

<P>
<A NAME="Exercises">
<HR><!------------------------------------------------------------------------>
<H2>Exercises</H2>
<UL>
</UL>
<P>
<A NAME="ESQ">
<HR><!------------------------------------------------------------------------>
<H2> Exam Style Questions </H2>
<UL> 
<LI> Describe and differentiate between <EM>pessimistic</EM> and 
     <EM>optimistic</EM> protocols for file symchronization.
<LI> How (in general terms) does RCS retrieve previous versions of a file?
<LI> What are the <TT>ci</TT> and <TT>co</TT> commands used for?
<LI> Explain the difference between the commands <TT>co -l foo.txt</TT> 
     and <TT>co foo.txt</TT>.
<LI> What RCS command is used to print the revision history of a file?
<LI> What do the <TT>rcsdiff</TT> and <TT>rcsmerge</TT> commands do?
</UL>
<HR><!------------------------------------------------------------------------>
</BODY>
</HTML>
