<HTML>
<HEAD>
<TITLE>Data</TITLE>
</HEAD>
<BODY ALIGN=JUSTIFY>
<HR><!------------------------------------------------------------------------>
<CENTER>
<H1>Data</H1>
</CENTER>
Last modified Monday, 22-Aug-2016 11:19:41 EDT.
<HR><!------------------------------------------------------------------------>
<UL>
<LI> Everything has a name, data type, and a storage class.
<P>
<LI> Block structure.<BR>
     <UL>
     <LI> Variables may be defined inside any <TT>{</TT>. This makes the
          variable local to that block, and remain in existance to the
          corresponding <TT>}</TT>. 
     <LI> The most local variable is the one used, from
          those in the innermost block out to external variables. The
          most common use is at the start of a function.
     <LI> Not encouraged, as it's hard to read, and potentially
          inefficient.
     <LI> <A HREF="MyCode/Scope.c"><TT>Scope.c</TT></A>
          - Loops of scope
     </UL>
<P>
<LI> Data types and sizes
     <UL>
     <LI> Basic types
          <UL>
          <LI> <TT>char</TT> - usually single byte
          <LI> <TT>int</TT> - two or four byte integer
          <LI> <TT>float</TT> - single precision reals
          <LI> <TT>double</TT> - double precision reals
          </UL>
     <LI> Specifiers
          <UL>
          <LI> <TT>int</TT> can be qualified by <TT>short</TT> or 
               <TT>long</TT>, indicating bigger and smaller integers. 
               The <TT>int</TT> can be omitted.
          <LI> <TT>char</TT> and any integer can be qualified by 
               <TT>signed</TT> or <TT>unsigned</TT>, indicating an integer 
               or natural value respectively. 
               The default for integers is <TT>signed</TT>. 
               <TT>unsigned char</TT> have values 0 - 255, signed from 
               -128 to 128.
               Plain <TT>char</TT> may be either, and is machine dependant.
          <LI> <TT>long double</TT> specifies extended floating point.
          </UL>
     <LI> Include files contain symbolic constants for the extreme values 
          of all types.
          <UL>
          <LI> <A HREF="MyCode/NumericLimits.c"><TT>NumericLimits.c</TT></A>
               - Limits of various data types
          </UL>
     </UL>
<P>
<LI> Constants
     <UL>
     <LI> <TT>int</TT> decimal notation - sequence of digits<BR>
          <TT>int</TT> octal notation - leading zero<BR>
          <TT>int</TT> hexidecimal notation -  leading <TT>0x</TT> or 
          <TT>0X</TT>. 
          Characters in either case.
     <LI> <TT>long</TT> - either an <TT>int</TT> (any notation) whose value 
          is too large for an <TT>int</TT> or an <TT>int</TT> (any notation) 
          suffixed by <TT>l</TT> or <TT>L</TT>.
     <LI> <TT>unsigned</TT> - an <TT>int</TT> (any notation) suffixed by 
          <TT>u</TT> or <TT>U</TT>. 
          <TT>unsigned long</TT> followed by <TT>ul</TT> or <TT>UL</TT>.
     <LI> Reals - decimal form (no need for digits both side of point)
          or exponential form using <TT>e</TT> or <TT>E</TT> to denote the 
          exponent. 
          The type is <TT>double</TT> unless suffixed. 
          Suffix <TT>f</TT> or <TT>F</TT> indicates a <TT>float</TT> constant, 
          <TT>l</TT> or <TT>L</TT> a <TT>long double</TT> constant.
     <LI> <TT>char</TT> - character in single quotes. These are converted to
          their internal value and can appear in numeric operations.
          Non-printables are represented in single quotes using <TT>\</TT>.
          They are 
          <UL>
          <LI> <TT>\n</TT> = newline
          <LI> <TT>\t</TT> = tab
          <LI> <TT>\a</TT> = bell
          <LI> <TT>\b</TT> = backspace
          <LI> <TT>\r</TT> = carriage return
          <LI> <TT>\f</TT> = formfeed
          <LI> <TT>\v</TT> = vertical tab
          <LI> <TT>\\</TT> = backslash
          <LI> <TT>\'</TT> = single quote
          <LI> <TT>\"</TT> = double quote
          <LI> <TT>\?</TT> = question mark.
          </UL>
          <TT>char</TT>s may be prefixed with <TT>l</TT> or <TT>L</TT> to 
          indicate that an extended character set should be used.
     <LI> Any 8 bit pattern may be generated by <TT>\ddd</TT> or <TT>\xhh</TT> 
          where <TT>ddd</TT> and <TT>hh</TT> are small enough octal and hex 
          numbers to be char.  A special case is <TT>\0</TT>.
     <LI> Constant expression - expression only involving constants and
          hence evaluated at compile time.
     <LI> String constant - zero or more characters surrounded by double
          quotes. Escape characters may appear in the string. Internally
          a string corresponds to an array of char.
          <UL>
          <LI> The compiler appends the <TT>\0</TT> character to the end of 
               all such strings (and ones input) so their end can be found.
          <LI> String constants that are only separated by white space are
               concatenated by the compiler.
          <LI> Strings may be prefixed with <TT>l</TT> or <TT>L</TT> to 
               indicate that an extended character set should be used.
          </UL>
          <PRE>
//----Returns the length of s1 (This is in a library)
int strlen(char TheString[]) {

    int Length;

    Length = 0;
    while (TheString[Length] != '\0') {
        ++Length;
    }
    return(Length);
} </PRE>
     <LI> Enumeration constants - these are discussed later.
     </UL>
<P>
<LI> Storage classes
     <UL>
     <LI> Automatic objects.
          <UL>
          <LI> Local variables and formal parameters have, by
               default, the storage class <TT>auto</TT>.
          <LI> Automatic variables come into existance on invocation
               and disappear when the function is exited. 
          </UL>
     <LI> Register variables.
          <UL>
          <LI> A variable declared to be <TT>register</TT> informs the compiler
               that it will be used heavily. Where possible such variables
               are maintained in machine registers. This is achieved by
               preceeding the declaration with the word <TT>register</TT>.
          <LI> Register can only be applied to automatic variables and
               function arguments (which are automatic).
          <LI> <A HREF="MyCode/RegisterVar.c"><TT>RegisterVar.c</TT></A>
               - Program with a register variable
          </UL>
     <LI> Static objects.
          <UL>
          <LI> Objects may be declared <TT>static</TT> to make them permanent 
               or private. 
               This achieved by prefixing the definition with the
               word <TT>static</TT>.
          <LI> Internal static variables in functions remain in existance
               even after the function has exited. Very useful indeed.
          <LI> <A HREF="MyCode/StaticCallCounter.c"><TT>
               StaticCallCounter.c</TT></A>
               - Program with a static counter in a function.
          </UL>
     <LI> External objects.
          <UL>
          <LI> All objects defined at the outer level in a file, e.g.
               functions, are external objects.
          <LI> Externals are defined once only, but may be declared often.
          <LI> Each function that uses an external object must either
               declare it with an explicit <TT>extern</TT> declaration, or the
               object must be declared earlier in the same file to provide
               an implicit declaration. 
          <LI> External (global) variables may be defined outside any
               function and then exist independently of the functions.
               <UL>
               <LI> <A HREF="MyCode/Externals.c"><TT>Externals.c</TT></A>
                    - Program to find the longest line in the input.
               <LI> External variables will give you warts, and may be used only
                    when there's no alternative, e.g., interrupt handling.
               <LI> If you have to use them, put them at the end of the file
                    to force <TT>extern</TT> declarations.
               </UL>
          <LI> C programs can be kept in several source files and external
               objects are visible between files.
               <UL>
               <LI> <TT>extern</TT> declarations may be at the external level, 
                    or within a function. 
                    In the latter case the object is only known locally. 
               <LI> <A HREF="MyCode/ExternData.c"><TT>ExternData.c</TT></A>
                    - External data definition<BR>
                    <A HREF="MyCode/UseExternData.c">
                    <TT>UseExternData.c</TT></A>
                    - Use of external data definition
               </UL>
          <LI> Put externals at the end or in a separate file, and you'll 
               force yourself to declare them
          <LI> External static objects cannot be accessed from any other
               file. This is useful for "local" routines in libraries.
               <UL>
               <LI> <A HREF="MyCode/ExternalStatic.c"><TT>ExternalStatic.c</TT></A>
                    - Program to find the longest line in the input.
               <LI> Good idea for encapsulation
               </UL>
          </UL>
     </UL>
<P>
<LI> Type qualification.
     <UL>
     <LI> These precede definitions and declarations.
     <LI> The <TT>const</TT> qualifier indicates that the objects cannot 
          have its value changed.
     <LI> The <TT>volatile</TT> qualifier indicates that the object's value may
          change out of control of the program. e.g. clock variable.
     </UL>
<P>
<LI> Initialization.
     <UL>
     <LI> Variables may be initialized at their definition, but not at a
          declaration.
     <LI> In the absence of explicit initialization, external and static
          variables are initialized to 0.
     <LI> Automatic and register variables have no default initialization.
     <LI> Aggregates may be initialized by following the definition with
          a list of initializers enclosed in <TT>{}</TT> separated by commas.
     <LI> If the variable is external or static the initialization is
          done once when the program is run (or equivalent), if
          automatic the initialization is done each time the function is
          called.
     <LI> For automatic and register variables the initializer may be
          any expression involving previously defined variables and
          functions.
     <LI> For external and static variables, and any initializers in 
          <TT>{}</TT>, the values must be constant expressions.
     <LI> The <TT>const</TT> qualifier may be applied to initialized 
          variables to indicate that their value will not change.
     <LI> <A HREF="MyCode/Initialization.c"><TT>Initialization.c</TT></A>
          - Initialized variables
     </UL>
<P>
<LI> Type conversions.
     <UL>
     <LI> There are several situatuations where it is necessary to
          convert one data type to another.
          <UL>
          <LI> Mixed expressions. In mixed expressions the type
               conversions and result type are governed by promotion
               rules.
               <UL>
               <LI> Firstly integral promotion takes place, converting 
                    <TT>char</TT>, <TT>short</TT>, bit fields, and 
                    <TT>enum</TT> constants to <TT>int</TT>  (or
                    <TT>unsigned int</TT> if too large).
               <LI> Then if either operand is of higher type, the other is
                    converted to that type. The order is 
                    <TT>long double</TT> >
                    <TT>double</TT> > 
                    <TT>float</TT> > 
                    <TT>unsigned long int</TT> > 
                    <TT>long int</TT> (with an exception) > 
                    <TT>unsigned int</TT> > 
                    <TT>int</TT>.
               </UL>
          <LI> Assignment across types, the value on the RHS is converted
               to the type of the variable on the LHS.
          <LI> Actual argument values are converted to the formal argument
               type when a function is called.
          <LI> Casting. Type conversions can be forced by casting an
               expression into a type using the construct :
               <PRE>
(&lt;type>) &lt;expression> </PRE>
          </UL>
     <LI> The rules for these conversions are :
          <UL>
          <LI> <TT>char</TT> to <TT>int</TT> - <TT>char</TT>s and <TT>int</TT>s
               may be freely mixed in expressions as <TT>char</TT> are 
               converted to <TT>int</TT>. 
               As <TT>char</TT> are represented as byte it is possible for 
               the msb to be interpreted as a sign bit. 
               In the conversion to <TT>int</TT> some machines (including the 
               PDP11) will do sign extension, so the conversion may produce 
               a negative integer. 
               Other machines will simply pad with zeros. C guarantees that
               characters in the machine's standard printing character set
               will never be negative (i.e., will have <TT>int</TT> values 
               <TT>0</TT> to <TT>127</TT>).
               <P>
               A problem arises when <TT>char</TT>s are compared with 
               <TT>int</TT>s on machines which do not provide sign extension. 
               The <TT>char</TT> is converted to <TT>int</TT> for the 
               comparison and will always be positive. 
               Thus if the <TT>int</TT> is negative the two can never be
               equal. An important case of this is when <TT>EOF</TT> is 
               <TT>-1</TT>. 
               This is the reason for using an <TT>int</TT> to hold characters 
               returned by <TT>getchar()</TT>.
          <LI> Any <TT>int</TT> to any <TT>unsigned</TT> - in 2's complement 
               arithmetic the bit pattern representing the integer is copied 
               across.
               Extra bits are truncated if the unsigned is narrower, 0
               fill and sign extend if the unsigned is wider.
          <LI> Any <TT>int</TT> to any signed type, the value is unchanged 
               if it fits, undefined otherwise.
          <LI> Logical to <TT>int</TT> - logical expressions that are true are
               defined to have the value 1 and those that are false the
               value 0.
          <LI> Any integral to any floating type, directly copied if it
               fits, undefined otherwise.
          <LI> <TT>float</TT> to <TT>int</TT> - the fractional part is 
               truncated, but the direction of truncation for -ve values and 
               the method of dealing with overflow is undefined.
          <LI> Larger floating point to smaller floating point - done by
               rounding if its fits, undefined otherwise.
          <LI> Smaller floating point to larger floating point - straight
               assignment with zero padding.
          </UL>
     </UL>
<P>
<LI> Type definitions.
     <UL>
     <LI> Besides the storage classes <TT>auto</TT>, <TT>extern</TT> and 
          <TT>register</TT>, which are used when allocating storage, there 
          is a storage class <TT>typedef</TT> which defines synonyms for 
          data types.
     <LI> The format is the same as for variable definition. 
     <LI> <A HREF="MyCode/Typedef.c"><TT>Typedef.c</TT></A>
          - Typedef and strings
     <LI> Good for structured programming.
     </UL>
<P>
</UL>
<A NAME="Exercises">
<HR><!------------------------------------------------------------------------>
<H2> Exercises </H2>
<UL>
<LI> Find out if the version of C you are using does sign extension
     when converting <TT>char</TT> to <TT>int</TT>.
<LI> Write a program to read two characters, and print their value
     when interpreted as a 2-digit hexadecimal number. Accept upper 
     case letters for values from 10 to 15. 
</UL>
<A NAME="ESQ">
<HR><!------------------------------------------------------------------------>
<H2> Exam Style Questions </H2>
<UL>
<LI> Any of the short <A HREF="#Exercises">exercises</A>.
<LI> What are the four basic data types of C? 
<LI> Which of the following are keywords in C? <List of words>
<LI> How are integer constants expressed using decimal, octal, and 
     hexidecimal?
<LI> What are the key features of {automatic|register|external|static}
     variables?
<LI> Give an example showing how an array may be initialized when defined.
<LI> At what point during a program's execution are {automatic|external|static}
     variables initialized?
</UL>
<HR><!------------------------------------------------------------------------>
</BODY>
</HTML>
